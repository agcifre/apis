<?xml version="1.0" encoding="UTF-8"?>
<!-- edited with XMLSpy v2011 sp1 (http://www.altova.com) by End User (free.org) -->
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:add="http://bced.wallonie.be/data/entity/address/v1" xmlns:cod="http://bced.wallonie.be/data/common/code/v1" targetNamespace="http://bced.wallonie.be/data/entity/address/v1" elementFormDefault="qualified" attributeFormDefault="unqualified">
	<xs:annotation>
		<xs:documentation>
			Definitions of address-related types.
		</xs:documentation>
	</xs:annotation>
	<xs:import namespace="http://bced.wallonie.be/data/common/code/v1" schemaLocation="../../common/code_v1.xsd"/>
	<xs:complexType name="AddressType" abstract="true">
		<xs:annotation>
			<xs:documentation>
				The base class for address types. The base address must contain a country code.
				If, for whatever reason, it does not exist or cannot be filled in, it must explicitly
				be set to nil.
				The base class is abstract and no non-abstract elements can exist with this type. It sole
				purpose is to define the mandatory fields of an address. Instances must use any of the subtypes.
			</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="country" type="cod:CodeType" nillable="true">
				<xs:annotation>
					<xs:documentation>
						The country information may consist of a country code and
						a language-dependent name, hence the CodeType definition.
					</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="trust" type="cod:TrustType" use="optional"/>
		<xs:attribute name="source" type="cod:CodeSourceType" use="optional"/>
		<xs:attribute name="modificationDate" type="xs:date"/>
		<xs:attribute name="addressType">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="belgianAddress"/>
					<xs:enumeration value="foreignAddress"/>
					<xs:enumeration value="diplomaticPost"/>
					<xs:enumeration value="temporaryAddress"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="StructuredAddressType">
		<xs:annotation>
			<xs:documentation>
				A structured address consists of a street name, a house number, a house number extension, a postcode,
				a municipality, and a province or state indicator, in addition to the country already defined in 
				the base type.
				Street name, house number, postcode and municipality are mandatory fields, the house number extension 
				and provice or state indicator are optional fields.
				If any of the mandatory fields is not known, it is considered an incomplete address, and the unknown
				field must explicitly be set to nil.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="add:AddressType">
				<xs:sequence>
					<xs:element name="street" type="cod:CodeType" nillable="true">
						<xs:annotation>
							<xs:documentation>
								The street information may consist of a street code and
								a language-dependent name, hence the CodeType definition.
							</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="houseNumber" nillable="true">
						<xs:annotation>
							<xs:documentation>
								A house number is generally a digit, but by defining it as
								a string, this is not enforced. It must be at least one
								character long, and cannot start with whitespace.
							</xs:documentation>
						</xs:annotation>
						<xs:simpleType>
							<xs:restriction base="xs:string">
								<xs:pattern value="[^\s].*"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:element>
					<xs:element name="houseNumberExtension" minOccurs="0">
						<xs:annotation>
							<xs:documentation>
								A house number extension is required to deal with appartments
								or other addresses sharing the same front door. This is a 
								free-format string, but it must be at least one character long and 
								cannot start with whitespace.
							</xs:documentation>
						</xs:annotation>
						<xs:simpleType>
							<xs:restriction base="xs:string">
								<xs:pattern value="[^\s].*"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:element>
					<xs:element name="postCode" type="cod:SimpleCodeType" nillable="true">
						<xs:annotation>
							<xs:documentation>
								The postcode of the address. It is of type simpleCodeType
								because it only consists of a code, without description.
							</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="municipality" type="cod:CodeType" nillable="true">
						<xs:annotation>
							<xs:documentation>
								The municipality information may consist of a municipality code and
								a language-dependent name, hence the CodeType definition.
							</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="provinceOrState" type="cod:CodeType" minOccurs="0">
						<xs:annotation>
							<xs:documentation>
								The province or state information may consist of a code and
								a language-dependent name, hence the CodeType definition.
							</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="UnstructuredAddressType">
		<xs:annotation>
			<xs:documentation>
				An unstructured address consists of zero or more (max. 10) free text lines.
				For certain Belgian addresses, a municipality can be optionally added in coded
				form.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="add:AddressType">
				<xs:sequence>
					<xs:element name="municipality" type="cod:CodeType" minOccurs="0">
						<xs:annotation>
							<xs:documentation>
								The municipality information may consist of a municipality code and
								a language-dependent name, hence the CodeType definition.
							</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="line" type="xs:string" minOccurs="0" maxOccurs="10"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:element name="structuredAddress" type="add:StructuredAddressType" nillable="true">
		<xs:annotation>
			<xs:documentation>
				Root element holding a structured address.
			</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="unstructuredAddress" type="add:UnstructuredAddressType" nillable="true">
		<xs:annotation>
			<xs:documentation>
				Root element holding an unstructured address.
			</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="address">
		<xs:annotation>
			<xs:documentation>
				Root element holding an address of one of the subtypes.
			</xs:documentation>
			<!-- 
			Because not all XML web service frameworks correctly interprete substitution groups, it was decided
			to work with XML choices instead of substitution groups. This means that you will always have an element
			'person' which contains a subelement 'simplePerson' or 'detailedPerson.'
			Using substitution groups would be simpler and yields cleaner XML; it also more extensible and looser
			coupled than choice groups. Hence, it is advisable to change the choice-group constructions in the
			future and to prefer substitution groups.
			-->
		</xs:annotation>
		<xs:complexType>
			<xs:choice>
				<xs:element ref="add:structuredAddress"/>
				<xs:element ref="add:unstructuredAddress"/>
			</xs:choice>
		</xs:complexType>
	</xs:element>
</xs:schema>
